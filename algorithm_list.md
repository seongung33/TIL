# list
## 시작하기 전
 다양한 사람의 코드를 많이 보기  
 APS 기본 학습
 - 기초 자료 구조 이해 중심
   - 입출력을 제외한 내장함수 사용 X
 - Ai 활용 방법
   - 학습에 도움을 받는 용도  
 코드가 외워질 정도로 반복하기
     
## 알고리즘 
문제를 해결하기 위한 절차나 방법  

의사코드(슈도코드, Pseudocode)와 순서도  
컴퓨터 분야에서 알고리즘을 표현하는 방법  
**성능**  
정확성 > 작업량 > 메모리 사용량 > 단순성 > 최적성
### 시간 복잡도
- 알고리즘의 작업량을 표현할 떄 시간 복잡도로 표현합니다.
- 시간 복잡도(Time Complexity)
  - 실제 걸리는 시간을 측정
  - 실행되는 명령문의 개수를 계산
    
**시간 복잡도 표기법**  
빅-오 표기법 (Big-O Notation)  
O(3n + 2) = O(3n) = O(n)  
최고차항 선택 및 계수 제거  
입력 값에 따른 연산 수 비교  
O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n) < O(n!)  

## 배열 (list)
일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조  
필요성
 - 프로그램 내에서 여러개의 변수가 필요할 때
 - 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언
 - 단순히 다수의 변수 선언을 의미하는 것이 아님  
배열은 그림을 그려 파악하는 것이 중요하다. 


## 연습문제
2번  어떤원소 arr[i]의 오른쪽에 더 작은 수의 개수 == 낙차  
2차원 X  

## 정렬
정렬의 종류
 - 버블 정렬
 - 퀵 정렬
 - 카운팅 정렬
 - 삽입 정렬
 - 선택 정렬
 - 병합 정렬

## 버블 정렬  
1. 첫 번쨰 원소부터 **인접한 원소끼리** 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다
2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.  
**시간 복잡도 : O(n^2)** 
![버블 정렬 예시](../study/image.png)  
다음 반복은 마지막이 확정되었으므로 다시 처음부터 반복하지만 마지막은 비교하지 않는다. 즉 **정렬할 구간이 감소한다.**  
의사코드
```
bubblesort(a, N)
  for i : N-1 -> 1 # i가 N-1 부터 1 까지 반복
      for j : 0 ->i-1
        if a[j] > a[j+1]
          a[j] <-> a[j+1]
```

## 파일 여는법
입력값 파일로 받기
```python
import sys
sys.stdin = open('sample_input.txt', 'r') # read
#출력값 파일에 적기
sys.stdout = open("sample_output.txt", "w") # write
``` 

##  카운팅 정렬
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 **세는 작업**을 하여, **선형 시간**에 정렬하는 효율적인 방식  
제한사항
1. 정수나 정수로 표현할 수 있는 자료에 대해서만 가능, 숫자열 값이 인덱스가 되어야 하기 때문
2. 집합 내에서 가장 큰 정수를 알아야 함  
**시간 복잡도: O(n + k)**: n은 리스트의 길이 k는 정수의 최댓값  두 값 중 큰 값의 영향 
```python
# 오름차순 
# 1 개수세기
counts = []*(max_v + 1)# 0~ 최댓값까지 이므로 list 수는 + 1
for i in range(n):
  counts[DATA[i]] += 1
# 2 누적합
for i in range(1, n):
  counts[i] = counts[i-1] + counts[i]
# 3 카운팅 정렬
# 데이터의 마지막 값부터 진행  
temp = [] *(max_v + 1)
for j in range(N-1, -1, -1):
  counts[DATA[j]] -= 1
  temp[counts[DATA[j]]] = data[DATA[j]]
```

## 완전 검색
**모든 경우의 수**를 나열해보고 확인하는 기법  
경우의 수가 작을 때 유용합니다.
완전 검색의 필요성  
- 해답을 찾아내지 못할 확률이 매우 작다
- 평가 등에서 주어진 문제를 풀때 완전 검색으로 해답을 도출한 후 다른 알고리즘으로 성능을 개선한다.
ex) Baby-gin Game  

### 순열
nPr = n*(n-1)\*(n-2)\*...\*(n-r+1) # r 개  
nPn = n!

## 탐욕 알고리즘( Greedy 문제 풀이 )
여러 경우 중 최적이라고 생각되는 것을 선택해 나가는 방식  
- 최적해를 구하는데 사용되는 근시안적 방법
- 각 선택의 시점에서 이뤄지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 답을 만들었다고 그것이 최적이라는 보장은 없다. 
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 구현하면 Greedy 접근법이다.  

1. 해 선택
2. 실행 가능성 검사
3. 해 검사
### 거스름돈 줄이기
어떻게 하면 손님에게 주는 거스름돈의 동전과 지폐의 개수가 가장 적을까?  
1. 500원 선택, 가장 큰 동전 선택
2. 거스름돈이 500원이 넘는가? 초과한다면 1단계로 돌아가 다음 동전을 선택한다.
3. 금액이 모자라면 1번으로 가서 다시 해 선택을 진행한다.  


문제: 800원을 줘야할 때 100, 400, 500원이 있을 경우 탐욕 알고리즘은 500, 100, 100, 100 을 택해 4개를 준다 하지만 이 경우 400원 두개가 가장 적은 개수이다.

### baby-gin  
```python
num = 456789
c = []*12
for i in range(6):
  c[num % 10] += 1
  num //= 10