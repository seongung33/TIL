# 프로그래밍 패러다임
## 절차 지향과 객체 지향
### 절차 지향 프로그래밍
변수와 함수를 별개로 다룸  
- 입력을 받고, 처리하고, 결과를 내는 과정이 위에서 아래로 순차적으로 흐름  
- 복잡성 증가
  - 프로그램 규모가 커질수록 데이터와 함수의 관리가 어려움
  - 전역 변수의 증가로 인한 관리의 어려움
- 유지보수 문제
  - 코드 수정 시 영향 범위 파악이 어려움
### 객체 지향 프로그래밍
클래스는 **설계도**, 인스턴스는 **실제 물건**  
- 데이터(변수)와 그 데이터를 처리하는 함수(메서드)를 하나의 단위로 묶어서 조직적으로 관리
- 데이터와 메서드의 결합  
- 객체간의 상호작용이 중요하다.
- 객체지향에서는 데이터와 해당 데이터를 처리하는 메서드가 하나의 객체로 통합된다.

### 비교
절차 지향: 어떤 순서로 처리할까?  
객체 지향: 어떤 객체이가 이 문제를 해결할까?, 이 객체는 어떤 속성과 기능을 가질까?  
서로 대조되는 개념은 아니다. 객체지향이란 개념을 도입해 상속, 코드 재사용성, 유지 보수성 등의 이점을 가지는 패러다임

## 객체와 클래스
객체: 실제 존재하는 사물을 추상화 한 것 '속성' 과 '동작'을 가짐  
클래스: 객체를 만들기 위한 설계도, 데이터와 기능을 함께 묶는 방법을 제공

- 객체(예시)
  - 속성(변수)
    - 직업: 가수
    - 생일: 1993년 5월 16일
    - 국적: 대한민국
  - 동작(메서드)
    - 랩()
    - 댄스()
    - 바이브레이션()  
클래스(가수) --> 객체(아이유, BTS)

## 클래스 기초
클래스는 관련된 데이터(속성)와 기능(메서드)을 하나의 '묶음'으로 정의하는 설계도(blueprint)  
1. 클래스 == 자동차 설계도
2. 속성 == 자동차의 데이터
3. 메서드 == 자동차의 기능 (가속하기, 정지하기, 방향 바꾸기 등)
4. 인스턴스 == 실제 자동차  

클래스 이름은 파스칼 케이스(Pascal Case) 방식으로 작성  
각 문자 앞을 대문자로 표기 / 변수, 함수와 구분하기 위해서
```python
class MyClass:
    pass
```
__init__ 메서드는 '생성자 메서드'라 불린다.  
## 인스턴스
클래스를 통해 생성된 객체  
클래스가 설계도라면 인스턴스는 그 설계도로부터 실제로 만든 "개별 물건"
person("alice", 25)이면 person이라는 설계도로부터 이름이 alice 이고 나이가 25인 객체 탄생

## 클래스와 인스턴스
인스턴스 표현법: a 는 b 클래스의 인스턴스다.  
a는 객체다 True, a는 인스턴스다 False  
- 클래스를 정의한다는 것은 **공통된 특성과 기능을 가진 틀**을 만드는 것
- 우리가 사용한 데이터 타입은 모두 클래스다.
```python
class Singer:
 
    pass
# iu와 bts는 Singer 클래스의 인스턴스
iu = Singer()
bts = Singer()
print(type(iu)) # <class '__main__.Singer'>
print(type(bts)) # <class '__main__.Singer'>

# 문자열 변수 name(Alice)은 str 클래스의 인스턴스이다.
name = 'Alice'
print(type(name)) # <class 'str'>
```
"hello".upper(): str 클래스의 인스턴스 hello의 메서드 upper 사용.  
문자열.대문자로(), 객체.행동(), 인스턴스.메서드()  
**하나의 객체(object)는 특정 클래스의 인스턴스(instance)이다.**

## 클래스 구성요소
- 생성자 메서드
  - 인스턴스 생성 시 자동호출 되는 특별한 메서드
  - __init__이라는 이름의 메서드로 정의
  - 인스턴스 변수의 초기화 담당
```python
class Circle:
    pi = 3.14

    def __init__(self, radius):
        self.radius = radius
# 인스턴스 생성
c1 = Circle(1)
c2 = Cirecle(2)
#인스턴스 변수(속성) 접근
print(c1.radius) # 1
print(c2.radius) # 2
#클래스 변수(공통 속성) 접근
print(c1.pi) # 3.14
print(c2.pi) # 3.14
```
클래스 변수와 동일한 이름으로 인스턴스 변수 생성 시 클래스 변수가 아닌 인스턴스 변수에 먼저 참조하게 됨  

```python
ci.pi = 100
# 클래스 변수보다 먼저 인스턴스 변수인 100을 참조함
print(ci.pi) # 100
print(Cirecle.pi) # 3.14
```

## 메서드
클래스 내부에 정의된 함수로 해당 객체가 어떻게 동작할지를 정의  
**인스턴스.메서드()**
### 인스턴스 메서드
인스턴스가 쓰는 메서드. 인스턴스의 상태를 조작하거나 동작을 수행합니다.  
인스턴스 메서드 구조
  - 반드시 첫 번째 인자로 인스턴스 자신(self)을 받음  
반드시 첫 번째 인자가 자기 자신인 이유:
  - 'hello'.upper() --> str.upper('hello')
  - 이는 객체 지향 메서드의 방식으로 호출하는 표현(단축형 호출)이다.
  - hello 중심적 표현인 객체 지향적 표현
```python
class Counter:
    def __init__(self):
        self.count = 0
    def increment(self):
        self.count += 1
c1 = Counter()
c2 = Counter()
print(c1.count) # 0
c1.increment()
print(c1.count) # 1
print(c2.count)
```

### 클래스 메서드
**클래스 변수를 조작**하거나 클래스 레벨의 **동작을 수행**합니다.  
**..?  다시 공부 필요**
```python
class MyClass:
    @classmethod
    def class_method(cls, arg, ...):
        pass
```

### 스태틱 메서드
- 호출 시 자동으로 전달 받는 인자가 없음
- @staticmethod

## 메서드 정리
1. 인스턴스 메서드
   - 인스턴스의 상태를 변경하거나, 해당 인스턴스의 특정 동작을 수행
2. 클래스 메서드
   - 인스턴스의 상태에 의존하지 않는 기능을 정의
   - 클래스 변수를 조작학나 클래스 레벨의 동작을 수행
3. 스태틱 메서드
   - 클래스 및 인스턴스와 관련이 없는 일반적인 기능을 수행  

**클래스가 사용해야 할 것**
- 클래스 메서드
- 스태틱 메서드  

**인스턴스가 사용해야 할 것**
- 인스턴스 메서드  

사실 클래스와 인스턴스가 모든 메서드를 호출할 수 있다.  
하지만 써도 된다는 것이 아니다.  

## 클래스와 인스턴스 간 이름 공간
파이썬 튜터 써보기  
독립적인 이름 공간을 가지는 이점  
  - 각 인스턴스는 독립적인 메모리 공간을 가진다. 
  - 서로가 서로에게 영향을 끼칠 수 없음
  - 클래스와 인스턴스를 모듈화하고 각각의 객체가 독립적으로 동작하도록 보장
  - 클래스와 인스턴스는 다른 객체들과의 상호작용에서 충돌이나 영향을 주지 않으며 독립적이다.
  - 코드의 가독성, 유지보수성, 재사용성을 높인다.

## 데코레이터
